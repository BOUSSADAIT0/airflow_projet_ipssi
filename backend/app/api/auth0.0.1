from fastapi import APIRouter, HTTPException, Depends, status
from datetime import datetime, timedelta
from typing import Optional
import jwt
import bcrypt

from app.schemas.user import User, UserCreate, UserLogin, Token
from app.config import settings

router = APIRouter(prefix="/api/auth", tags=["Authentication"])

# Base de données simulée
users_db = {}

def get_password_hash(password: str) -> str:
    salt = bcrypt.gensalt()
    hashed = bcrypt.hashpw(password.encode('utf-8'), salt)
    return hashed.decode('utf-8')

def verify_password(plain_password: str, hashed_password: str) -> bool:
    try:
        return bcrypt.checkpw(
            plain_password.encode('utf-8'), 
            hashed_password.encode('utf-8')
        )
    except:
        return False

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
    return encoded_jwt

# Initialiser l'utilisateur démo
demo_user = {
    "id": 1,
    "username": "aitdjoudi@gmail.com",
    "email": "aitdjoudi@gmail.com",
    "full_name": "Boussad",
    "hashed_password": get_password_hash("boussad"),
    "is_active": True,
    "is_superuser": False,
    "created_at": datetime.now(),
    "updated_at": datetime.now()
}
users_db["aitdjoudi@gmail.com"] = demo_user

@router.post("/register", response_model=User)
async def register(user_data: UserCreate):
    """Enregistre un nouvel utilisateur"""
    if user_data.username in users_db:
        raise HTTPException(status_code=400, detail="Nom d'utilisateur déjà utilisé")
    
    user_id = len(users_db) + 1
    user = {
        "id": user_id,
        "email": user_data.email,
        "username": user_data.username,
        "full_name": user_data.full_name or "",
        "hashed_password": get_password_hash(user_data.password),
        "is_active": True,
        "is_superuser": False,
        "created_at": datetime.now(),
        "updated_at": datetime.now()
    }
    
    users_db[user_data.username] = user
    return User(**user)

@router.post("/login", response_model=Token)
async def login(user_data: UserLogin):
    """Authentifie un utilisateur"""
    user = users_db.get(user_data.username)
    
    if not user:
        raise HTTPException(
            status_code=401,
            detail="Nom d'utilisateur ou mot de passe incorrect"
        )
    
    if not verify_password(user_data.password, user["hashed_password"]):
        raise HTTPException(
            status_code=401,
            detail="Nom d'utilisateur ou mot de passe incorrect"
        )
    
    access_token = create_access_token(data={"sub": user["username"]})
    return Token(access_token=access_token, token_type="bearer")

@router.get("/me", response_model=User)
async def get_current_user(token: str):
    """Récupère les informations de l'utilisateur connecté"""
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        username = payload.get("sub")
        
        if not username or username not in users_db:
            raise HTTPException(status_code=401, detail="Token invalide")
        
        return User(**users_db[username])
    except jwt.ExpiredSignatureError:
        raise HTTPException(status_code=401, detail="Token expiré")
    except jwt.JWTError:
        raise HTTPException(status_code=401, detail="Token invalide")

@router.post("/refresh")
async def refresh_token(token: str):
    """Rafraîchit le token d'authentification"""
    try:
        # Accepter les tokens expirés pour le rafraîchissement
        payload = jwt.decode(
            token, 
            settings.SECRET_KEY, 
            algorithms=[settings.ALGORITHM],
            options={"verify_exp": False}
        )
        
        username = payload.get("sub")
        if not username or username not in users_db:
            raise HTTPException(status_code=401, detail="Token invalide")
        
        new_token = create_access_token(data={"sub": username})
        return Token(access_token=new_token, token_type="bearer")
    except jwt.JWTError:
        raise HTTPException(status_code=401, detail="Token invalide")

@router.post("/logout")
async def logout():
    """Déconnecte l'utilisateur"""
    return {"success": True, "message": "Déconnexion réussie"}