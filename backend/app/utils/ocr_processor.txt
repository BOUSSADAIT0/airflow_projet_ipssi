import pytesseract
from PIL import Image, ImageEnhance, ImageFilter
import pdf2image
import io
import base64
import json
import os
from typing import Dict, Any, List, Optional, Tuple
import tempfile
import cv2
import numpy as np
from datetime import datetime
import logging

logger = logging.getLogger(__name__)

class OCRProcessor:
    def __init__(self, tesseract_path: str = None, default_language: str = "fra+eng"):
        if tesseract_path:
            pytesseract.pytesseract.tesseract_cmd = tesseract_path
        self.default_language = default_language
        
    def process_file(self, file_content: bytes, filename: str, language: str = None) -> Dict[str, Any]:
        """
        Traite un fichier et extrait le texte
        """
        try:
            # Déterminer le type de fichier
            file_ext = os.path.splitext(filename)[1].lower()
            
            # Convertir en images si nécessaire
            if file_ext == '.pdf':
                images = self._pdf_to_images(file_content)
            else:
                images = [self._load_image(file_content)]
            
            results = []
            total_text = ""
            
            for i, image in enumerate(images):
                # Prétraitement de l'image
                processed_image = self._preprocess_image(image)
                
                # Extraction OCR
                page_result = self._extract_text(processed_image, language or self.default_language)
                
                # Détection des zones
                zones = self._detect_zones(processed_image, language or self.default_language)
                
                results.append({
                    'page': i + 1,
                    'text': page_result['text'],
                    'confidence': page_result['confidence'],
                    'zones': zones
                })
                total_text += page_result['text'] + "\n\n"
            
            # Analyse sémantique pour extraction structurée
            structured_data = self._analyze_text(total_text, filename)
            
            return {
                'success': True,
                'text': total_text,
                'pages': results,
                'structured_data': structured_data,
                'total_pages': len(images),
                'average_confidence': sum(r['confidence'] for r in results) / len(results) if results else 0
            }
            
        except Exception as e:
            logger.error(f"Erreur lors du traitement OCR: {str(e)}")
            return {
                'success': False,
                'error': str(e),
                'text': '',
                'structured_data': {},
                'total_pages': 0,
                'average_confidence': 0
            }
    
    def _pdf_to_images(self, pdf_content: bytes, dpi: int = 300) -> List[Image.Image]:
        """Convertit un PDF en liste d'images"""
        try:
            images = pdf2image.convert_from_bytes(pdf_content, dpi=dpi)
            return images
        except Exception as e:
            logger.error(f"Erreur conversion PDF: {str(e)}")
            raise
    
    def _load_image(self, image_content: bytes) -> Image.Image:
        """Charge une image depuis des bytes"""
        try:
            return Image.open(io.BytesIO(image_content))
        except Exception as e:
            logger.error(f"Erreur chargement image: {str(e)}")
            raise
    
    def _preprocess_image(self, image: Image.Image) -> Image.Image:
        """Prétraite l'image pour améliorer l'OCR"""
        # Convertir en niveaux de gris
        if image.mode != 'L':
            image = image.convert('L')
        
        # Améliorer le contraste
        enhancer = ImageEnhance.Contrast(image)
        image = enhancer.enhance(2)
        
        # Réduire le bruit
        image = image.filter(ImageFilter.MedianFilter(size=3))
        
        # Seuillage adaptatif
        img_array = np.array(image)
        img_array = cv2.adaptiveThreshold(
            img_array, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, 
            cv2.THRESH_BINARY, 11, 2
        )
        
        return Image.fromarray(img_array)
    
    def _extract_text(self, image: Image.Image, language: str) -> Dict[str, Any]:
        """Extrait le texte de l'image"""
        try:
            # Configuration Tesseract
            custom_config = r'--oem 3 --psm 6'
            
            # Extraction avec données détaillées
            data = pytesseract.image_to_data(
                image, 
                lang=language,
                config=custom_config,
                output_type=pytesseract.Output.DICT
            )
            
            # Calcul de la confiance moyenne
            confidences = [float(c) for c in data['conf'] if int(c) > 0]
            avg_confidence = sum(confidences) / len(confidences) / 100 if confidences else 0
            
            # Reconstruction du texte
            text = ' '.join([word for word, conf in zip(data['text'], data['conf']) 
                           if int(conf) > 0])
            
            return {
                'text': text,
                'confidence': avg_confidence,
                'raw_data': data
            }
            
        except Exception as e:
            logger.error(f"Erreur extraction texte: {str(e)}")
            return {
                'text': '',
                'confidence': 0,
                'raw_data': {}
            }
    
    def _detect_zones(self, image: Image.Image, language: str) -> List[Dict[str, Any]]:
        """Détecte les zones de texte dans l'image"""
        try:
            # Utiliser Tesseract pour détecter les blocs
            osd = pytesseract.image_to_osd(image, output_type=pytesseract.Output.DICT)
            
            # Détection des blocs de texte
            boxes = pytesseract.image_to_boxes(
                image, 
                lang=language,
                output_type=pytesseract.Output.DICT
            )
            
            zones = []
            if boxes:
                # Regrouper les caractères proches en mots
                current_word = ''
                current_box = None
                
                for i in range(len(boxes['char'])):
                    char = boxes['char'][i]
                    left = boxes['left'][i]
                    right = boxes['right'][i]
                    top = boxes['top'][i]
                    bottom = boxes['bottom'][i]
                    
                    if not current_word:
                        current_word = char
                        current_box = [left, top, right, bottom]
                    else:
                        # Vérifier si le caractère suivant est proche
                        if left - current_box[2] < 10:  # 10 pixels de marge
                            current_word += char
                            current_box[2] = right
                            current_box[3] = max(current_box[3], bottom)
                        else:
                            # Ajouter le mot précédent
                            zones.append({
                                'text': current_word,
                                'x': current_box[0],
                                'y': current_box[1],
                                'width': current_box[2] - current_box[0],
                                'height': current_box[3] - current_box[1],
                                'type': 'word'
                            })
                            # Commencer un nouveau mot
                            current_word = char
                            current_box = [left, top, right, bottom]
                
                # Ajouter le dernier mot
                if current_word:
                    zones.append({
                        'text': current_word,
                        'x': current_box[0],
                        'y': current_box[1],
                        'width': current_box[2] - current_box[0],
                        'height': current_box[3] - current_box[1],
                        'type': 'word'
                    })
            
            return zones
            
        except Exception as e:
            logger.error(f"Erreur détection zones: {str(e)}")
            return []
    
    def _analyze_text(self, text: str, filename: str) -> Dict[str, Any]:
        """Analyse le texte pour extraire des données structurées"""
        try:
            structured_data = {}
            
            # Détection du type de document basé sur le nom de fichier et le contenu
            doc_type = self._detect_document_type(filename, text)
            structured_data['document_type'] = doc_type
            
            # Extraction basée sur le type de document
            if doc_type == 'invoice':
                structured_data.update(self._extract_invoice_data(text))
            elif doc_type == 'receipt':
                structured_data.update(self._extract_receipt_data(text))
            elif doc_type == 'contract':
                structured_data.update(self._extract_contract_data(text))
            
            # Extraction d'informations générales
            structured_data.update(self._extract_general_info(text))
            
            return structured_data
            
        except Exception as e:
            logger.error(f"Erreur analyse texte: {str(e)}")
            return {}
    
    def _detect_document_type(self, filename: str, text: str) -> str:
        """Détecte le type de document"""
        filename_lower = filename.lower()
        text_lower = text.lower()
        
        # Détection basée sur le nom de fichier
        if any(word in filename_lower for word in ['facture', 'invoice', 'bill']):
            return 'invoice'
        elif any(word in filename_lower for word in ['recu', 'receipt', 'ticket']):
            return 'receipt'
        elif any(word in filename_lower for word in ['contrat', 'contract', 'agreement']):
            return 'contract'
        elif any(word in filename_lower for word in ['formulaire', 'form']):
            return 'form'
        
        # Détection basée sur le contenu
        if any(word in text_lower for word in ['facture', 'invoice', 'montant', 'total', '€', '$']):
            return 'invoice'
        elif any(word in text_lower for word in ['reçu', 'receipt', 'caisse', 'ticket']):
            return 'receipt'
        elif any(word in text_lower for word in ['contrat', 'contract', 'agreement', 'signature']):
            return 'contract'
        elif any(word in text_lower for word in ['nom', 'prénom', 'date', 'adresse', 'téléphone']):
            return 'form'
        
        return 'unknown'
    
    def _extract_invoice_data(self, text: str) -> Dict[str, Any]:
        """Extrait les données d'une facture"""
        data = {}
        lines = text.split('\n')
        
        for i, line in enumerate(lines):
            line_lower = line.lower()
            
            # Numéro de facture
            if any(word in line_lower for word in ['facture n°', 'invoice no', 'ref']):
                data['invoice_number'] = line.strip()
            
            # Date
            elif any(word in line_lower for word in ['date', 'le ']):
                if 'date' in line_lower or 'le ' in line_lower:
                    data['date'] = line.strip()
            
            # Montant total
            elif any(word in line_lower for word in ['total', 'montant', 'sum']):
                # Chercher les nombres dans la ligne
                import re
                amounts = re.findall(r'[\d,]+\.?\d*', line)
                if amounts:
                    data['total_amount'] = amounts[-1]
            
            # Informations client
            elif any(word in line_lower for word in ['client', 'customer', 'à l\'attention']):
                if i + 1 < len(lines):
                    data['client_name'] = lines[i + 1].strip()
        
        return data
    
    def _extract_receipt_data(self, text: str) -> Dict[str, Any]:
        """Extrait les données d'un reçu"""
        data = {}
        lines = text.split('\n')
        
        for i, line in enumerate(lines):
            line_lower = line.lower()
            
            # Date et heure
            if any(word in line_lower for word in ['date', 'heure', 'time']):
                data['date_time'] = line.strip()
            
            # Magasin
            elif any(word in line_lower for word in ['magasin', 'store', 'restaurant']):
                data['store'] = line.strip()
            
            # Total
            elif any(word in line_lower for word in ['total', 'montant']):
                import re
                amounts = re.findall(r'[\d,]+\.?\d*', line)
                if amounts:
                    data['total'] = amounts[-1]
        
        return data
    
    def _extract_contract_data(self, text: str) -> Dict[str, Any]:
        """Extrait les données d'un contrat"""
        data = {}
        lines = text.split('\n')
        
        for i, line in enumerate(lines):
            line_lower = line.lower()
            
            # Parties
            if any(word in line_lower for word in ['entre', 'between', 'parties']):
                if i + 2 < len(lines):
                    data['party1'] = lines[i + 1].strip()
                    data['party2'] = lines[i + 2].strip()
            
            # Date
            elif any(word in line_lower for word in ['fait le', 'signed on', 'date']):
                data['signature_date'] = line.strip()
        
        return data
    
    def _extract_general_info(self, text: str) -> Dict[str, Any]:
        """Extrait des informations générales"""
        data = {}
        
        # Email
        import re
        emails = re.findall(r'[\w\.-]+@[\w\.-]+\.\w+', text)
        if emails:
            data['emails'] = emails
        
        # Téléphones
        phones = re.findall(r'[\+\(]?[0-9][0-9\-\(\)\.]{8,}[0-9]', text)
        if phones:
            data['phones'] = phones
        
        # Dates
        date_patterns = [
            r'\d{1,2}[/-]\d{1,2}[/-]\d{2,4}',
            r'\d{4}[/-]\d{1,2}[/-]\d{1,2}',
            r'\d{1,2}\s+[a-zA-Z]+\s+\d{4}'
        ]
        dates = []
        for pattern in date_patterns:
            dates.extend(re.findall(pattern, text))
        if dates:
            data['dates'] = dates
        
        # Adresses (simplifié)
        address_keywords = ['rue', 'avenue', 'boulevard', 'street', 'road', 'zip', 'postal']
        lines = text.split('\n')
        for line in lines:
            if any(keyword in line.lower() for keyword in address_keywords):
                if 'address' not in data:
                    data['address'] = line.strip()
        
        return data